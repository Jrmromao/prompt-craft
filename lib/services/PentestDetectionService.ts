import { SecurityAuditService } from './SecurityAuditService';

interface RequestPattern {
  ip: string;
  userAgent: string;
  endpoint: string;
  method: string;
  timestamp: Date;
}

export class PentestDetectionService {
  private static instance: PentestDetectionService;
  private requestHistory: Map<string, RequestPattern[]> = new Map();
  private securityAudit = SecurityAuditService.getInstance();

  private constructor() {}

  public static getInstance(): PentestDetectionService {
    if (!PentestDetectionService.instance) {
      PentestDetectionService.instance = new PentestDetectionService();
    }
    return PentestDetectionService.instance;
  }

  async analyzeRequest(req: {
    ip: string;
    userAgent: string;
    url: string;
    method: string;
  }): Promise<{ suspicious: boolean; reason?: string }> {
    const pattern: RequestPattern = {
      ip: req.ip,
      userAgent: req.userAgent,
      endpoint: req.url,
      method: req.method,
      timestamp: new Date(),
    };

    // Store request pattern
    const key = req.ip;
    if (!this.requestHistory.has(key)) {
      this.requestHistory.set(key, []);
    }
    
    const history = this.requestHistory.get(key)!;
    history.push(pattern);
    
    // Keep only last 100 requests per IP
    if (history.length > 100) {
      history.shift();
    }

    // Analyze for suspicious patterns
    const analysis = this.detectSuspiciousPatterns(history);
    
    if (analysis.suspicious) {
      await this.securityAudit.logSecurityEvent({
        type: 'SUSPICIOUS_ACTIVITY',
        ipAddress: req.ip,
        userAgent: req.userAgent,
        details: {
          reason: analysis.reason,
          endpoint: req.url,
          method: req.method,
        },
        severity: 'HIGH',
      });
    }

    return analysis;
  }

  private detectSuspiciousPatterns(history: RequestPattern[]): { suspicious: boolean; reason?: string } {
    const recent = history.filter(r => Date.now() - r.timestamp.getTime() < 60000); // Last minute
    
    // Check for rapid requests (potential automated scanning)
    if (recent.length > 20) {
      return { suspicious: true, reason: 'High request frequency' };
    }

    // Check for directory traversal attempts
    const traversalPatterns = /\.\.|%2e%2e|%252e%252e/i;
    if (recent.some(r => traversalPatterns.test(r.endpoint))) {
      return { suspicious: true, reason: 'Directory traversal attempt' };
    }

    // Check for SQL injection patterns
    const sqlPatterns = /(union|select|insert|update|delete|drop|create|alter|exec|script)/i;
    if (recent.some(r => sqlPatterns.test(r.endpoint))) {
      return { suspicious: true, reason: 'SQL injection attempt' };
    }

    // Check for XSS patterns
    const xssPatterns = /<script|javascript:|onload=|onerror=/i;
    if (recent.some(r => xssPatterns.test(r.endpoint))) {
      return { suspicious: true, reason: 'XSS attempt' };
    }

    // Check for scanning tools
    const scannerUserAgents = /sqlmap|nikto|nessus|burp|owasp|scanner|crawler|bot/i;
    if (recent.some(r => scannerUserAgents.test(r.userAgent))) {
      return { suspicious: true, reason: 'Security scanner detected' };
    }

    // Check for unusual endpoint patterns (accessing many different endpoints)
    const uniqueEndpoints = new Set(recent.map(r => r.endpoint)).size;
    if (uniqueEndpoints > 15) {
      return { suspicious: true, reason: 'Endpoint enumeration' };
    }

    return { suspicious: false };
  }

  // Clean up old request history
  cleanup(): void {
    const cutoff = Date.now() - 24 * 60 * 60 * 1000; // 24 hours ago
    
    for (const [ip, history] of this.requestHistory.entries()) {
      const filtered = history.filter(r => r.timestamp.getTime() > cutoff);
      
      if (filtered.length === 0) {
        this.requestHistory.delete(ip);
      } else {
        this.requestHistory.set(ip, filtered);
      }
    }
  }
}
