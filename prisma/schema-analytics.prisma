// Analytics-focused schema additions
// Add these to your existing schema.prisma

model PromptRun {
  id              String   @id @default(cuid())
  userId          String
  promptId        String?
  model           String
  inputText       String   @db.Text
  outputText      String   @db.Text
  inputTokens     Int
  outputTokens    Int
  totalTokens     Int
  cost            Float
  latency         Int      // milliseconds
  success         Boolean?
  rating          Int?     // 1-5 stars
  feedback        String?  @db.Text
  metadata        Json?
  createdAt       DateTime @default(now())
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  prompt          Prompt?  @relation(fields: [promptId], references: [id], onDelete: SetNull)
  
  @@index([userId, createdAt])
  @@index([promptId])
  @@index([model])
  @@index([createdAt])
  @@map("prompt_runs")
}

model ApiKey {
  id              String   @id @default(cuid())
  userId          String
  provider        String   // openai, anthropic, google
  encryptedKey    String   @db.Text
  keyPreview      String   // last 4 chars for display
  isActive        Boolean  @default(true)
  lastUsed        DateTime?
  usageCount      Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, provider])
  @@index([userId])
  @@map("api_keys")
}

model OptimizationSuggestion {
  id                String   @id @default(cuid())
  userId            String
  type              String   // cost, performance, quality
  title             String
  description       String   @db.Text
  potentialSavings  Float?
  impact            String?
  actionUrl         String?
  status            String   @default("active") // active, dismissed, applied
  appliedAt         DateTime?
  createdAt         DateTime @default(now())
  
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, status])
  @@index([createdAt])
  @@map("optimization_suggestions")
}

model UsageAlert {
  id              String   @id @default(cuid())
  userId          String
  type            String   // cost_threshold, usage_spike, low_success_rate
  threshold       Float?
  currentValue    Float?
  message         String   @db.Text
  isRead          Boolean  @default(false)
  createdAt       DateTime @default(now())
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isRead])
  @@index([createdAt])
  @@map("usage_alerts")
}

model DailyUsageSummary {
  id              String   @id @default(cuid())
  userId          String
  date            DateTime @db.Date
  totalRuns       Int
  totalCost       Float
  totalTokens     Int
  successRate     Float?
  avgLatency      Int?
  modelBreakdown  Json     // { "gpt-4": { runs: 10, cost: 5.0 }, ... }
  createdAt       DateTime @default(now())
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, date])
  @@index([userId, date])
  @@map("daily_usage_summaries")
}

// Add these relations to existing User model:
// apiKeys              ApiKey[]
// promptRuns           PromptRun[]
// optimizationSuggestions OptimizationSuggestion[]
// usageAlerts          UsageAlert[]
// dailyUsageSummaries  DailyUsageSummary[]
